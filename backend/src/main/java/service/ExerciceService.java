package service;


import DTO.ConceptDTO;
import DTO.ExampleSolutionDTO;
import DTO.ExerciseDTO;
import DTO.TestsDTO;
import model.*;
import repository.ConceptRepository;
import repository.ExerciceRepository;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;


/**
 * Service layer component responsible for managing the core business logic for the Exercise entity
 */
@ApplicationScoped
public class ExerciceService {

    @Inject
    ExerciceRepository repository;

    @Inject
    TeacherService teacherService;

    @Inject
    ConceptRepository conceptRepository;

    /**
     * Retrieves all Exercise entities from the repository.
     * @return A List of all Exercise entities.
     */
    @Transactional
    public List<Exercise> getAll() {
        return repository.listAll();
    }



    /**
     * Retrieves a single Exercise entity by its id.
     * @param id The ID of the exercise.
     * @return The Exercise entity, or null if not found.
     */
    public Exercise getById(Long id) {
        return repository.findById(id);
    }


    /**
     * method to convert a list of TestsDTO Records into Tests entities.
     * This conversion is essential for decoupling the API contract from the persistence model.
     * @param list The DTO list received from the API call.
     * @param exo The Exercise entity to link the Tests to (handling the bidirectional relationship).
     * @return A list of Tests entities.
     */
    private List<Tests> TestDTOToTest(List<TestsDTO> list,Exercise exo){
        Objects.requireNonNull(list);
        var tests = new ArrayList<Tests>();
        if(!list.isEmpty()){
            for(var ele : list){
                var test = new Tests();
                test.setInput(ele.input());
                test.setOutput(ele.output());
                test.setHint(ele.hint());
                test.setExercise(exo);
                tests.add(test);
            }
        }
        return tests;
    }


    /**
     * method to convert a ConceptDTO into a Concept entity using "Find or Create" logic.
     * This ensures that Concepts are not duplicated if the theme already exists.
     * @param c The ConceptDTO containing the theme name.
     * @return The existing Concept entity, or a newly created and persisted one.
     */
    private Concept ConceptDTOToConcept(ConceptDTO c){
        Objects.requireNonNull(c);
        var theme = c.theme();
        var existingConcept = conceptRepository.findByTheme(theme);
        if (existingConcept.isPresent()) {
            return existingConcept.get();
        } else {
            var concept = new Concept();
            concept.setTheme(theme);
            conceptRepository.persist(concept);
            return concept;
        }
    }

    /**
     * method to convert the ExampleSolutionDTO Record into the ExampleSolution entity.
     * @param es The DTO containing the solution code and explanation.
     * @return The ExampleSolution entity.
     */
    private ExampleSolution ExampleSolutionDTOToExampleSolution(ExampleSolutionDTO es){
        Objects.requireNonNull(es);
        var example = new ExampleSolution();
        example.setCode(es.code());
        example.setExplication(es.explication());
        return example;
    }

    /**
     * method for creating a new Exercise.
     * his method handles cross-entity lookups, relationship binding, and persistence.
     * @param creationDTO The DTO containing all data generated by the LLM and validated by the teacher.
     * @return The newly created and persisted Exercise entity.
     * @throws IllegalArgumentException if the referenced teacher is not found.
     */
    @Transactional
    public Exercise createExercice(ExerciseDTO creationDTO) {
        var teacher = teacherService.findByName(creationDTO.teachername());
        if (teacher.isEmpty()) {
            throw new IllegalArgumentException("Professeur non trouv√©");
        }
        var newExercise = new Exercise();
        newExercise.setTitle(creationDTO.title());
        newExercise.setDescription(creationDTO.description());
        newExercise.setStatement(creationDTO.statement());
        newExercise.setDifficulty(Difficulty.valueOf(creationDTO.difficulty()));
        newExercise.setTeacher(teacher.get());
        newExercise.setTests(TestDTOToTest(creationDTO.tests(),newExercise));
        var concept = ConceptDTOToConcept(creationDTO.concept());
        concept.getExercises().add(newExercise);
        newExercise.setConcept(concept);
        newExercise.setExemple(ExampleSolutionDTOToExampleSolution(creationDTO.exemple()));
        repository.persist(newExercise);
        return newExercise;
    }



    /**
     * Deletes a specific exercise by ID, ensuring that all necessary bidirectional
     * relationships are cleaned up prior to deletion.
     * @param id The ID of the exercise to delete.
     * @return true if the deletion was successful (entity existed), false otherwise.
     */
    @Transactional
    public boolean deleteExercice(Long id) {
        var exo = repository.findById(id);
        var teacher = exo.getTeacher();
        var concept = exo.getConcept();
        concept.getExercises().remove(exo);
        if(teacher!= null && teacher.getExercises() != null){
            teacher.getExercises().remove(exo);
        }
        return repository.deleteById(id);
    }



}
